<div id="cesiumContainer"></div>

<script>
    Cesium.Ion.defaultAccessToken = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiIwMzQ2N2UzMi0wNzIzLTQzN2ItYWExYi0xZWM5MWZjNTQzNjUiLCJpZCI6MzE5MDk5LCJpYXQiOjE3NTE4NjY0NTJ9.Z7ZakLa9T-7er2aTf9m_MEhF8Di-gTDted1Xn-igj9U';
    console.log("siteData", window.siteData);
    var viewer = new Cesium.Viewer("cesiumContainer", {
        animation: false,
        baseLayerPicker: true,
        navigationHelpButton: false,
        sceneModePicker: true,
        homeButton: false,
        geocoder: true,
        fullscreenButton: true,
        timeline: false
    });

    // onpageshow 3d tiles
    // async function loadTileset(){
    //     const osmBuildingsTileset = await Cesium.createOsmBuildingsAsync();
    //     viewer.scene.primitives.add(osmBuildingsTileset);
    // }

    // loadTileset();

    // Add each point
    var pinBuilder = new Cesium.PinBuilder();

    window.siteData.forEach(function(point) {
        viewer.entities.add({
            name: point.site_code,
            position: Cesium.Cartesian3.fromDegrees(point.longitude, point.latitude, 1.0),
            billboard: {
                image: pinBuilder.fromUrl("./images/sensor.png", Cesium.Color.fromCssColorString('#3f51b5'), 48),
            },
            label: {
                text: point.site_name,
                font: "14pt sans-serif",
                style: Cesium.LabelStyle.FILL_AND_OUTLINE,
                outlineWidth: 2,
                verticalOrigin: Cesium.VerticalOrigin.BOTTOM,
                pixelOffset: new Cesium.Cartesian2(0, 10)
            }
        });
    });

    window.historicalData.forEach(point => {
                const pos = Cesium.Cartesian3.fromDegrees(point.longitude, point.latitude);

                // --------- 1. AQI via EllipsoidGraphics -----------
                const aqiColor = getAqiColor(point.aqi);
                viewer.entities.add({
                    name: `AQI: ${point.aqi}`,
                    position: pos,
                    ellipsoid: {
                        radii: new Cesium.Cartesian3(200, 200, 200),
                        material: aqiColor.withAlpha(0.3),
                    }
                });

                // --------- 2. Traffic via PointGraphics -----------
                const trafficCount = getTrafficDensityCount(point.traffic_density); // defines how many points
                const trafficColor = getTrafficFlowColor(point.traffic_flow); // inverse of density

                for (let i = 0; i < trafficCount; i++) {
                    // slight random offset to avoid exact overlap
                    const offset = Cesium.Cartesian3.fromDegrees(
                        point.longitude + (Math.random() - 0.5) * 0.0001,
                        point.latitude + (Math.random() - 0.5) * 0.0001
                    );

                    viewer.entities.add({
                        name: `Traffic: ${point.traffic_density}`,
                        position: offset,
                        point: {
                            pixelSize: 20,
                            color: trafficColor,
                        }
                    });
                }

                // --------- 3. Weather via PolylineArrow -----------
                addCenteredWindArrow(viewer, point.latitude, point.longitude, point.wind_deg, point.wind_speed);
            });

    // --- Color for AQI level ---
    function getAqiColor(aqi) {
        switch (aqi) {
            case 1: return Cesium.Color.LIME;
            case 2: return Cesium.Color.YELLOW;
            case 3: return Cesium.Color.BLUE;
            case 4: return Cesium.Color.ORANGE;
            case 5: return Cesium.Color.RED;
            default: return Cesium.Color.GRAY;
        }
    }

    // --- Traffic Density Count ---
    function getTrafficDensityCount(density) {
        switch (density) {
            case 'low': return 1;
            case 'moderate_low': return 3;
            case 'moderate': return 5;
            case 'moderate_high': return 7;
            case 'high': return 10;
            default: return 1;
        }
    }

    // --- Traffic Flow Color (inverse of density) ---
    function getTrafficFlowColor(flow) {
        switch (flow) {
            case 'low': return Cesium.Color.RED;
            case 'moderate_low': return Cesium.Color.ORANGE;
            case 'moderate': return Cesium.Color.YELLOW;
            case 'moderate_high': return Cesium.Color.GREEN;
            case 'high': return Cesium.Color.BLUE;
            default: return Cesium.Color.BLUE;
        }
    }

    // --- Weather/ Wind Data---
    function addCenteredWindArrow(viewer, lat, lon, wind_deg, wind_speed) {
        const length = 0.005 * wind_speed; // arrow total length in degrees
        const heading = Cesium.Math.toRadians(wind_deg);

        // Compute start and end points around the center
        const dx = (length / 2) * Math.sin(heading);
        const dy = (length / 2) * Math.cos(heading);

        const startLon = lon - dx;
        const startLat = lat - dy;
        const endLon = lon + dx;
        const endLat = lat + dy;

        viewer.entities.add({
            polyline: {
                positions: Cesium.Cartesian3.fromDegreesArray([
                    startLon, startLat,
                    endLon, endLat
                ]),
                width: 8,
                material: new Cesium.PolylineArrowMaterialProperty(Cesium.Color.CYAN),
            },
            label: {
                text: `💨 ${wind_speed.toFixed(1)} m/s`,
                font: '14px sans-serif',
                fillColor: Cesium.Color.DODGERBLUE,
                showBackground: true,
                backgroundColor: Cesium.Color.WHITE.withAlpha(0.6),
                verticalOrigin: Cesium.VerticalOrigin.BOTTOM,
                pixelOffset: new Cesium.Cartesian2(0, -20),
                position: Cesium.Cartesian3.fromDegrees(lon, lat),
            }
        });
    }


    function computeGeographicMidpoint(locations) {
        let x = 0, y = 0, z = 0;

        locations.forEach(loc => {
            const latRad = Cesium.Math.toRadians(loc.latitude);
            const lonRad = Cesium.Math.toRadians(loc.longitude);

            x += Math.cos(latRad) * Math.cos(lonRad);
            y += Math.cos(latRad) * Math.sin(lonRad);
            z += Math.sin(latRad);
        });

        const total = locations.length;
        x /= total;
        y /= total;
        z /= total;

        const hyp = Math.sqrt(x * x + y * y);
        const lat = Math.atan2(z, hyp);
        const lon = Math.atan2(y, x);

        return {
            latitude: Cesium.Math.toDegrees(lat),
            longitude: Cesium.Math.toDegrees(lon)
        };
    }

    var centrePoint = computeGeographicMidpoint(window.siteData);

    // Camera View set
    viewer.camera.setView({
        destination: Cesium.Cartesian3.fromDegrees(centrePoint.longitude, centrePoint.latitude, 2000.0),
        orientation: {
            heading: Cesium.Math.toRadians(0.0),
            pitch: Cesium.Math.toRadians(-40.0),
            roll: 0.0
        }
    });
</script>