<div id="cesiumContainer"></div>

<script>
    Cesium.Ion.defaultAccessToken = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiIwMzQ2N2UzMi0wNzIzLTQzN2ItYWExYi0xZWM5MWZjNTQzNjUiLCJpZCI6MzE5MDk5LCJpYXQiOjE3NTE4NjY0NTJ9.Z7ZakLa9T-7er2aTf9m_MEhF8Di-gTDted1Xn-igj9U';
    console.log("siteData", window.siteData);
    var viewer = new Cesium.Viewer("cesiumContainer", {
        animation: false,
        baseLayerPicker: true,
        navigationHelpButton: false,
        sceneModePicker: true,
        homeButton: false,
        geocoder: true,
        fullscreenButton: true,
        timeline: false
    });

    // onpageshow 3d tiles
    // async function loadTileset(){
    //     const osmBuildingsTileset = await Cesium.createOsmBuildingsAsync();
    //     viewer.scene.primitives.add(osmBuildingsTileset);
    // }

    // loadTileset();

    // Add each point
    var pinBuilder = new Cesium.PinBuilder();

    window.siteData.forEach(function(point) {
        viewer.entities.add({
            name: point.site_code,
            position: Cesium.Cartesian3.fromDegrees(point.longitude, point.latitude, 1.0),
            billboard: {
                image: pinBuilder.fromUrl("./images/sensor.png", Cesium.Color.fromCssColorString('#3f51b5'), 48),
            },
            label: {
                text: point.site_name,
                font: "14pt sans-serif",
                style: Cesium.LabelStyle.FILL_AND_OUTLINE,
                outlineWidth: 2,
                verticalOrigin: Cesium.VerticalOrigin.BOTTOM,
                pixelOffset: new Cesium.Cartesian2(0, 10)
            }
        });
    });

    window.historicalData.forEach(point => {
                const pos = Cesium.Cartesian3.fromDegrees(point.longitude, point.latitude);

                // --------- Traffic via PointGraphics -----------
                const trafficCount = getTrafficDensityCount(point.traffic_density); // defines how many points
                const trafficColor = getTrafficFlowColor(point.traffic_flow); // inverse of density

                for (let i = 0; i < trafficCount; i++) {
                    // slight random offset to avoid exact overlap
                    const offset = Cesium.Cartesian3.fromDegrees(
                        point.longitude + (Math.random() - 0.5) * 0.0001,
                        point.latitude + (Math.random() - 0.5) * 0.0001
                    );

                    viewer.entities.add({
                        name: `Traffic: ${point.traffic_density}`,
                        position: offset,
                        point: {
                            pixelSize: 20,
                            color: trafficColor,
                        }
                    });
                }
            });

    // --- Traffic Density Count ---
    function getTrafficDensityCount(density) {
        switch (density) {
            case 'low': return 1;
            case 'moderate_low': return 3;
            case 'moderate': return 5;
            case 'moderate_high': return 7;
            case 'high': return 10;
            default: return 1;
        }
    }

    // --- Traffic Flow Color (inverse of density) ---
    function getTrafficFlowColor(flow) {
        switch (flow) {
            case 'low': return Cesium.Color.RED;
            case 'moderate_low': return Cesium.Color.ORANGE;
            case 'moderate': return Cesium.Color.YELLOW;
            case 'moderate_high': return Cesium.Color.GREEN;
            case 'high': return Cesium.Color.BLUE;
            default: return Cesium.Color.BLUE;
        }
    }


    function computeGeographicMidpoint(locations) {
        let x = 0, y = 0, z = 0;

        locations.forEach(loc => {
            const latRad = Cesium.Math.toRadians(loc.latitude);
            const lonRad = Cesium.Math.toRadians(loc.longitude);

            x += Math.cos(latRad) * Math.cos(lonRad);
            y += Math.cos(latRad) * Math.sin(lonRad);
            z += Math.sin(latRad);
        });

        const total = locations.length;
        x /= total;
        y /= total;
        z /= total;

        const hyp = Math.sqrt(x * x + y * y);
        const lat = Math.atan2(z, hyp);
        const lon = Math.atan2(y, x);

        return {
            latitude: Cesium.Math.toDegrees(lat),
            longitude: Cesium.Math.toDegrees(lon)
        };
    }

    var centrePoint = computeGeographicMidpoint(window.siteData);

    // Camera View set
    viewer.camera.setView({
        destination: Cesium.Cartesian3.fromDegrees(centrePoint.longitude, centrePoint.latitude, 2000.0),
        orientation: {
            heading: Cesium.Math.toRadians(0.0),
            pitch: Cesium.Math.toRadians(-40.0),
            roll: 0.0
        }
    });
</script>